import pefile 
import random # to gen a random int in range 
import mmap 
import binascii
import struct  

#swap the byte order of a 32-bit integer 
def swap32(val):
    return struct.unpack("<I",struct.pack(">I",val))[0]

def unsigned_subtraction(a, b):
    mask = 2 **32 - 1  # Calculate the mask based on the bit length of 'a
    result = (a - b) & mask  # Perform the subtraction and apply the mask
    return result

def get_bss_rva_raw_data_size_data(file):
    file = open(file,"rb")
    parsed_data = mmap.mmap(file.fileno(),0,access= mmap.ACCESS_READ) #reading the file in ACCESS_READ memory mapped object 
    pe = pefile.PE(data=parsed_data , fast_load=True)
    for section in pe.sections:
        if 'bss' in section.Name.decode():
                print("[+]located bss section[+]\n")
                BSS_RVA = section.VirtualAddress 
                BSS_RAWSIZE = section.SizeOfRawData 
                DATA_BYTES = section.get_data() # bss section data as binary string 
                DATA_RAW_STR = binascii.hexlify(DATA_BYTES).decode().split("00000000")[0]
                return BSS_RVA,BSS_RAWSIZE,DATA_RAW_STR # returns a 3 element tuple 
                #print(f"bss rva:0x{hex(BSS_RVA)},bss raw size:0x{ hex(BSS_RAWSIZE)}")

    file.close()
    return None,None,None 



def save_decrypted_int_bytes(lst_ints):
    with open("bytes","w") as f :
            f.write(','.join(map(str, lst_ints)))
            f.close()


#ISFB bss malware config decode routine 
#deccode data in dwords 
def decode(data,bss_rva,bss_size):
    # get a number between 1 and 19 to use as magic value in the algo
    """
          v4 = NtQuerySystemInformation(SystemProcessorPerformanceInformation, allocated_heap, dwBytes, &ReturnLength);// the main reason it's calling this routine,is to get the system IdelTime and use it to caclulate a value 
          ExitCode = (unsigned __int16)v4;
          if ( (unsigned __int16)v4 == 4 )
            dwBytes += 48;
          run_time_val = allocated_heap->IdleTime.LowPart % 0x13 + v4 + 1;// takes the mod of the first dword in allocated_heap(idleTime) with 0x13 adds the NTSTATUS code and then 1 ,to get a number between 1 and 0x13 
          HeapFree_wrapper(allocated_heap);
        }
        else
        {
          ExitCode = 8;    
    """  
    encode = [data[i:i+8]for i in range(0,len(data),8)]
    encode = [int(hex_dword,16)for hex_dword in encode] # list of dword encoded bytes 
    #print(encode)
    zero_dword = 0x00000000 # dword representation of zero 
    temp = 0  # initially is set to zero 
    decode = []
    run_time = 0x13 
    # # pick up an random integer that works for the algorithm (pass the algorithm check)
    # run_time = random.randint(1,19) # get a random integer between 1 & 19 
    # while(run_time):
        # test = run_time - 1 & 1 # calculate test value 
        # if not test:  # if test i a zero 
            # print("current run_time:0x%x"%run_time) 
            # break 
        # run_time = random.randint(1,19) # get another random integer 
    test = run_time - 1 & 1 # calculate test value 
    #where the algorithm starts 
    eax = bss_rva  # 0x5000
    # eax = test = eax -> 0 - 0x5000
    ecx = run_time 
    if test < eax:
        pass
    else:
        eax = test - eax 
    
    eax = eax + unsigned_subtraction(ecx , 0x7E47C838) # calulated value, will be used later to decode the encoded config data 
    key = eax # set key value 
    print("key:0x%x"%eax)
    ebx = zero_dword # initialize ebx 
    
    for i in range(len(encode)):
        try:
            cur_encoded_dword = swap32(encode[i])
        except Exception as E:
            print(encode[i])
            print("[!]stop decoding")
            print(E)
            break      
        ebx = unsigned_subtraction(ebx, key)
        #print("ebx:0x%x"%ebx)
        eax = ebx + cur_encoded_dword
        ebx = cur_encoded_dword 
        decoded_dword = struct.pack("<I",eax & 0xFFFFFFFF)
        decode.append(decoded_dword)
           
    decoded_data_bytes = b"".join(decode) # join the decrypted dwords (binary string objects) together 
    print("decrypted config string:")
    print(decoded_data_bytes.decode())
    line = binascii.hexlify(decoded_data_bytes) #hex representation of the decrypted binary string 
    #list of bytes 
    lst_bytes = [line[i:i+2]for i in range(0,len(line),2)]
    lst_ints = []
    for byte in lst_bytes:
        lst_ints.append(int(byte,16))
    
    print("in bytes:")
    print(lst_ints)
    return lst_ints

   
def main():
    file = input("Enter path to ISFB:")
    bss_rva , bss_size, bss_data  = get_bss_rva_raw_data_size_data(file)
    int_bytes = decode(bss_data,bss_rva,bss_size)
    save_decrypted_int_bytes(int_bytes)








if __name__ == "__main__":
    main()
 
