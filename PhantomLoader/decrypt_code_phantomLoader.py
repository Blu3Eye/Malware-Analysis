import re
import idaapi 
import idc 
import idautils 
import ida_kernwin
def read_bytes(start_ea,size):
    data = idaapi.get_bytes(start_ea,size)
    if data is None:
        print(f"Failed to read bytes at {hex(start_ea)}")
    return data



def decrypt_bytes(key,data,size):
    #encrypted data bytes buffer 
    enc_data_bytes = bytearray(data)
    buffer = [0] * 0x5F5E100
    #iterate through encrypted data bytes buffer to decrypt 
    for i in range(size):
        idx =  i + 665 * i * buffer[0]
        enc_data_bytes[idx] ^= key[i % len(key)]
    return bytes(enc_data_bytes)
        


def patch_bytes_in_idb(key,start_ea,size):
    # Read the encrypted data from the IDA database
    encrypted_data = read_bytes(start_ea,size)
    # Decrypt the data
    decrypted_data = decrypt_bytes(key,encrypted_data,size)
    # Write the decrypted data back to the IDA database
    idaapi.patch_bytes(start_ea,decrypted_data)

"""
def find_start_enc_code_size(data):
    pattern = rb'\xC7\x45.\x00\x00\x00\x00\xC7\x45.{5}\xC7\x45.(?P<start_ea>....)\xC7\x45\xD0(?P<size>\xD0\x07)\x00\x00'
    match = re.search(pattern,data)
    if match:
        start_ea = int.from_bytes(match.group('start_ea'),byteorder='little')
        size = int.from_bytes(match.group('size'),byteorder='little')
        print(f"enc_code_start_addr:{start_ea}")
        print(f"size:{size}")
        return start_ea,size
    else:
        print("[+]Failed to find encrypted code start address")
        sys.exit(1)
"""

    
def find_key():
    pattern = rb'\xC6\x45[\x00-\xFF](?P<group>[\x20-\x7E])'
    global data
    mov_null_byte_pat = re.compile(rb'\xC6.{2}\x00')
    #gets the path of the current IDB file 
    idb_file = idc.get_idb_path()
    # Prompts the user to select a file, starting in the directory of the current IDB file.
    file = ida_kernwin.ask_file(0, "*.*", f"Select a file (current directory: {idb_file})")
    if file == None:
        print("[*]Failed to get file path")
        sys.exit(1)
    with open(file,'rb') as f:
         data = f.read()
    
    key = b""
    prev_addr = None
    for match in re.finditer(pattern, data):
        address = match.start()
        character = match.group(1)
        if prev_addr is None or address - prev_addr == 4:
            key += character
            prev_addr = address
            null_byte_check = data[address+4:address+8]
            if mov_null_byte_pat.match(null_byte_check):
                break
        elif address - prev_addr > 4:
            key = ""
            key += character
            prev_addr = address
    return key.decode('ascii')            
    
    
if __name__ == "__main__":
    key_ascii = find_key()
    #addr,size = find_start_enc_code_size(data)
    #check for NUL, add it if it was not there 
    if key_ascii[-1] != '\x00':
        key_ascii = key_ascii + '\x00'
    key_lst = [ord(_)for _ in key_ascii]
    #start_ea = addr + 0x15d38 
    # you need to position your cursor on the address of the encrypted code block
    start_ea = ida_kernwin.get_screen_ea()
    size = 0x7D0
    patch_bytes_in_idb(key_lst,start_ea,size)
    print("[+]Done patching")
    
    
  