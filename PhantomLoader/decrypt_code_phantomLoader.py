import re
import idaapi 
import idc 
import idautils 

def read_bytes(start_ea,size):
    data = idaapi.get_bytes(start_ea,size)
    if data is None:
        print(f"Failed to read bytes at {hex(start_ea)}")
    return data



def decrypt_bytes(key,data,size):
    #encrypted data bytes buffer 
    enc_data_bytes = bytearray(data)
    buffer = [0] * 0x5F5E100
    #iterate through encrypted data bytes buffer to decrypt 
    for i in range(size):
        idx =  i + 665 * i * buffer[0]
        enc_data_bytes[idx] ^= key[i % len(key)]
    return bytes(enc_data_bytes)
        


def patch_bytes_in_idb(key,start_ea,size):
    # Read the encrypted data from the IDA database
    encrypted_data = read_bytes(start_ea,size)
    # Decrypt the data
    decrypted_data = decrypt_bytes(key,encrypted_data,size)
    # Write the decrypted data back to the IDA database
    idaapi.patch_bytes(start_ea,decrypted_data)
    
def find_key():
    pattern = rb'\xC6\x45[\x00-\xFF](?P<group>[\x20-\x7E])'
    mov_null_byte_pat = re.compile(rb'\xC6.{2}\x00')
    with open("phantom_loader.bin","rb") as f:
        data = f.read()
    
    key = b""
    prev_addr = None
    for match in re.finditer(pattern, data):
        address = match.start()
        character = match.group(1)
        if prev_addr is None or address - prev_addr == 4:
            key += character
            prev_addr = address
            null_byte_check = data[address+4:address+8]
            if mov_null_byte_pat.match(null_byte_check):
                break
        elif address - prev_addr > 4:
            key = ""
            key += character
            prev_addr = address
    return key.decode('ascii')            
    
    
if __name__ == "__main__":
    key_ascii = find_key()
    #check for NUL, add it if it was not there 
    if key_ascii[-1] != '\x00':
        key_ascii = key_ascii + '\x00'
    key_lst = [ord(_)for _ in key_ascii]
    start_ea = 0x00433B1E + 0x15d38 
    size = 0x7D0
    patch_bytes_in_idb(key_lst,start_ea,size)
    print("[+]Done patching")
    
    
  