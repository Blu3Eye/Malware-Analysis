import idautils 
import idaapi 
import idc
from Crypto.Cipher import AES
from Crypto.Util import Counter
import re 


#Iterate through all the functions in the IDB file, find the "ea" of string decryption function (first occurence of string decryption function)
def get_string_dec_func_ea(func_name):
    for func_ea in idautils.Functions():
        cur_fn_name = idc.get_func_name(func_ea)
        if func_name in cur_fn_name:
            return hex(func_ea)    

def find_xrefs_to_func(func_ea):
    #list of EAs(effective address) to string decryption function 
    ea_lst_frm = []
    for xref in idautils.XrefsTo(func_ea,flags=0):
        ea_lst_frm.append(hex(xref.frm))
    return ea_lst_frm

#get the address of each inst that loads the address of the encrypted string struct 
def get_enc_string_struct_inst_addr(ea_lst_frm):
    inst_lst = {}
    #find the address of lea ecx , encrypted_string_struct 
    for xref_hex in ea_lst_frm:
        xref = int(xref_hex,16)
        #7 bytes before the address of the call to string decryption function is the address of lea ecx , encrypted_string_struct (address of the inst that loads the encrypted string struct)
        for h in idautils.Heads(xref - 7 , xref):
            #check if found inst mnem is "lea" with the first operand being "rcx"
            # if it is then store the address of the second operand which should be our encrypted string struct as well as the inst of the addr 
            if idc.print_insn_mnem(h) == "lea" and print_operand(h,0) == "rcx":
                operand_1_hex = hex(idc.get_operand_value(h,1)) # get the second operand value (encrypted string struct)
                inst_lst[hex(h)] ={
                'enc_string_struct_addr_hexstr' : operand_1_hex
                }
    return inst_lst

def process_enc_string_struct(inst_lst_addrs_hex):
    #process each encrypted string struct, extract the length,IV and encrypted bytes to decrypt 
    enc_string_struct_lst = []
    enc_string_attrs = {}
    i = 0
    for inst_addr,string_dict in inst_lst_addrs_hex.items():
        enc_string_struct_addr = int(string_dict['enc_string_struct_addr_hexstr'] ,16)
        enc_string_struct_lst.append(enc_string_struct_addr)
    for addr in enc_string_struct_lst:
        #read first 2 bytes at enc_string_struct_addr to get the length 
        i+=1
        string_length_bytes = idc.get_bytes(addr,2)
        string_length_int = int.from_bytes(string_length_bytes,byteorder='little')
        
        iv_bytes = idc.get_bytes(addr+2,16)
        iv_hexstr = iv_bytes.hex()
        
        enc_bytes = idc.get_bytes(addr+2+16,string_length_int)
        enc_bytes_hexstr = enc_bytes.hex()
        
        enc_string_attrs [f'string{i}'] = {
        'length_int':string_length_int,
        'iv_bytes':iv_bytes,
        'enc_bytes':enc_bytes
        }
    return enc_string_attrs

def aes_decrypt_strings(enc_string_attrs_dict,key_bytes):
    decrypted_strings = []
    for _ , string in enc_string_attrs_dict.items():
        iv = string['iv_bytes'] 
        encrypted_data = string['enc_bytes']
        ctr = Counter.new(128,initial_value=int.from_bytes(iv,byteorder='big'))
        cipher = AES.new(key_bytes,AES.MODE_CTR,counter=ctr)
        decrypted_data = cipher.decrypt(encrypted_data)
        decrypted_strings.append(decrypted_data)
    return decrypted_strings


#find and extract AES-256 stack string key
#go to the function,examine its bytes and then extract the key
def get_aes_key(func_ea):
    #navigate to the string decryption function 
    idc.jumpto(func_ea)
    start_addr = func_ea
    end_addr = idc.get_func_attr(start_addr,idc.FUNCATTR_END)
    data = idc.get_bytes(start_addr,end_addr - start_addr)
    key_pattern = rb'\xC6\x44\x24[\x00-\xFF](.)'
    prev_addr = None
    key = bytearray()
    
    for match in re.finditer(key_pattern,data):
        addr = match.start()
        key_byte = match.group(1)
        if prev_addr is None or addr - prev_addr == 5:
            prev_addr = addr
            key.append(key_byte[0])
    return bytes(key)

def add_cmts(ea_lst_frm,decrypted_strings):
    xrefs_strings_lst = list(zip(ea_lst_frm,decrypted_strings))
    for xfrm_hexstr,string_bytes in xrefs_strings_lst:
        xfrm_int = int(xfrm_hexstr,16)
        try:
            decoded_string = string_bytes.decode('ascii')
        except UnicodeDecodeError:
            try:
                decoded_string = string_bytes.decode('utf-16')
            except UnicodeDecodeError:
                decoded_string  = ""
     
        set_cmt(xfrm_int,decoded_string,False)
    print("Finished adding comments")
    
def main():
    func_ea_hex = get_string_dec_func_ea('aes_ctr_mode_str_decrypt')
    func_ea = int(func_ea_hex,16)
    key_bytes = get_aes_key(func_ea)
    #list of xrefs to string decryption function 
    ea_lst_frm = find_xrefs_to_func(func_ea)
    inst_lst_addrs_hex = get_enc_string_struct_inst_addr(ea_lst_frm)
    enc_string_attrs_dict = process_enc_string_struct(inst_lst_addrs_hex)
    decrypted_strings = aes_decrypt_strings(enc_string_attrs_dict,key_bytes)
    #save decrypted strings 
    with open('latrodectus_strings.txt','wb') as f:
        for str in decrypted_strings:
            f.write(str)
            f.write(b'\n')
        f.close()
    print("Saved strings to file")
    #add decrypted strings to IDB as comments 
    add_cmts(ea_lst_frm,decrypted_strings)
if __name__ == '__main__':
    main()